
import Color exposing (..)
import Collage exposing (..)
import Element exposing (..)
import Keyboard
import Text
import Time exposing (..)
import Window exposing (Size)
import AnimationFrame
import Html exposing (..)
import Html.App as App
import Task
import Array exposing (..)

import Point exposing (..)
import Drone exposing (..)

--(gameWidth,gameHeight) = (600,400)
(gameWidth,gameHeight) = (900,600)


--SCENARIO

weights = [4,2,7,3,1]
droneMaxLoad = 12

-- MODEL

type State 
  = Play 
  | Pause

type alias Game =
  {  state : State
  , turn : Int
  , size : Size
  , drone : Drone
  , queue : List (Drone -> Drone)
  }

type alias Input =
  { space : Bool
  , delta : Time
  }

model : Game
model =
  { state = Pause
  , turn = 0
  , drone = initDrone 0 0
  , queue = []
  }

load : Point -> Int -> Int -> Drone -> List( Drone -> Drone )
load p t n d =
  let
    x = round <| distance d.position p
    f = List.repeat x (flyTo p)
  in
    f ++ [take t n]

deliver : Point -> Int -> Int -> Drone -> List( Drone -> Drone )
deliver p t n d =
  let
    x = round <| distance d.position p
    f = List.repeat x (flyTo p)
  in
    f ++ [drop t n]

initDrone = newDrone droneMaxLoad <| List.length weights

totalWeight : Drone -> Int
totalWeight a =
  List.foldr (+) 0 <| List.map2 (*) weights <| toList a.products

--UPDATE

update : Input -> Game -> Game
update {space} ({state, turn, drone, queue} as game) =
  let
    state' = if space then Play else Pause
    newTurn = if state' == Play then 1+turn else turn
    newQueue' = if state' == Play && queue == [] then
        if items drone == 0 then
          queue ++ load (Point 20 5) 1 5 drone
        else
          queue ++ deliver (Point 5 20) 1 5 drone
      else
        queue
    newQueue = if state' == Play then List.drop 1 newQueue' else newQueue'

    cmd = if state' == Play then List.head newQueue' else Nothing
    newDrone =
      case cmd of
        Nothing -> drone
        Just z -> Debug.log "next" (z drone)

  in
    { game |
      state = state',
      turn = newTurn,
      drone = newDrone,
      queue = newQueue
    }

-- VIEW

view : Game -> Html Msg
view model =
  let
    {width, height} = 
      model.size
    scores =
      txt identity ("Turn " ++ toString game.turn)
        Pause ->
          txt identity ("Turn " ++ toString model.turn)
        _ ->
          spacer 1 1
    info =   
      case model.state of
        Pause ->
          txt identity msg
        _ ->
          spacer 1 1
    wareShapes =
      List.map (make 5 wareColor) model.warehouses
    orderShapes =
      List.map (make 5 orderColor) model.orders
    dronesShapes =
      List.map (make 3 droneColor) model.drones
  in
    toHtml <|
    container width height middle <|
    collage gameWidth gameHeight ( List.concat
     [ rect gameWidth gameHeight
          |> filled backgroundColor
      , toForm scores
          |> move (0, gameHeight/2 - 40)
        , toForm info
          |> move (0, 40 - gameHeight/2)
      , make 5 white game.drone.position
      ]

backgroundColor =
  rgb 10 10 10

wareColor =
  blue

orderColor =
  red

droneColor =
  white

textColor =
  rgb 160 200 160


txt f string =
  Text.fromString string
    |> Text.color textColor
    |> Text.monospace
    |> f
    |> leftAligned


msg = "press SPACE to start/pause"

make r c obj =
  oval r r
    |> filled c
    |> move (obj.x, obj.y)



keyboardProcessor keyCode =
  case keyCode of
    32 -> TogglePlay
    _ -> NoOp

init =
  (defaultGame, Task.perform (\_ -> NoOp) Resize (Window.size))

main =
  App.program
    { init = init
    , update = \msg m -> update msg m ! []
    , view = view
    , subscriptions =
      (\_ -> Sub.batch
        [ Window.resizes Resize
        , Keyboard.ups keyboardProcessor
        --, Keyboard.downs (keyboardProcessor True)
        --, Keyboard.ups (keyboardProcessor False)
        , AnimationFrame.diffs (Tick<<inSeconds)
        ])
    }